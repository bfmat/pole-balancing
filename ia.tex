\documentclass[12pt]{article}

\usepackage[margin=1in]{geometry}
\usepackage{parskip}
\usepackage{amsmath}
\usepackage[style=ieee]{biblatex}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{caption}

\graphicspath{{./images/}}

\addbibresource{ia.bib}

\begin{document}

\title{Applying State Space Control and LQR to the Pole Balancing Problem}
\author{Brendon Matusch}
\date{November 2018}
\maketitle

\section{Introduction}

\subsection{The Pole Balancing Problem}

One of the most famous problems in control theory is the \textit{pole balancing problem}, also known as \textit{cart pole}. The basic idea of the problem is as follows:

\begin{itemize}
    \item A movable cart with mass $M$ sits on a two-dimensional, straight track, at horizontal position $x$.
    \item A pole with length $l$ is anchored to the cart with a hinge at angle $\theta$ (which can change).
    \item A weight with mass $m$ is attached to the end of the pole.
    \item A motor can accelerate the cart to the left or right with force $F$.
    \item Gravity, which applies downward force $g$, is present.
    \item The goal is to prevent the pole from falling over (to prevent $\theta$ from becoming too large), while also keeping the cart near the center of the track (keeping $x$ small).
\end{itemize}

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.5\textwidth]{cartpole}
    \caption{\label{cartpole} A diagram of the pole balancing problem.}
\end{figure}

This problem, as visualized in Figure \ref{cartpole}, is quite clearly not trivial. If the pole starts to fall to the right, one must accelerate the cart to the right to prevent it from falling over. However, that also results in the cart moving away from the center. Thus, to successfully optimize both the angle and the position, one must gradually adjust the angle by applying small forces while the cart moves.

\subsection{Control Algorithms}

The most common classical control solution to this kind of problem is the PID (proportional, integral, and derivative) closed control loop. While it is well-known that this can work, it is relatively difficult to optimize. PID loops are only able to optimize one variable at a time (for instance, the angle of the pole, or the position of the cart). Optimizing multiple variables (as is required here) necessitates nesting of PID loops, which frequently have to be optimized either manually or via machine learning.

An alternative control method, which can optimize multiple variables with one or more inputs, is state space control. Rather than dealing with only a single variable, state space controllers can optimize an entire vector of states in a single linear function, making for a simpler and more elegant solution.

For this project, I have created a mathematical simulation of the pole balancing problem and developed a state space controller to effectively optimize it.

\subsection{Applications}

A state space solution to the pole balancing problem has many applications outside of this environment. For instance, control of many kinds of robots (such as two-wheeled vehicles and walking humanoid robots) is related to the pole balancing problem. I have learned a great deal along the way about how state space control algorithms can generalize onto real-world control problems.

\section{Environment}

\subsection{Equations of Motion}

In order to develop a solution to the pole-balancing problem, I first had to model it. Creating a physical cart pole setup would have taken a long time, so I used a simulated model instead. In order to develop this, I used the differential equations of motion for the pole balancing problem, which I found at \cite{polebalancing}:

\begin{equation}
    \ddot \theta = \frac{\displaystyle g \sin \theta + \cos \theta \left( \frac{\displaystyle -F - m l \dot \theta ^2 \sin \theta}{\displaystyle M + m} \right)}{\displaystyle l \left( \frac{\displaystyle 4}{\displaystyle 3} - \frac{\displaystyle m \cos ^2 \theta}{\displaystyle M + m} \right)}
\end{equation}

\begin{equation}
    \ddot x = \frac{\displaystyle F + m l \left( \dot \theta ^2 \sin \theta - \ddot \theta \cos \theta \right)}{\displaystyle M + m}
\end{equation}

Note the use of dot-derivative notation, where $\displaystyle \dot \theta = \frac{\displaystyle d \theta}{\displaystyle d t}$ and $\displaystyle \ddot \theta = \frac{\displaystyle d ^2 \theta}{\displaystyle d t ^2}$ (and respectively for $x$).

\subsection{Implementation}

I implemented these equations of motion in Python 3 using NumPy \cite{numpy}. The following constants were used:

\begin{itemize}
    \item $M = 1$
    \item $m = 0.1$
    \item $l = 0.5$
    \item $g = 9.81$
\end{itemize}

The differential equations of motion refer to a continuous environment, where acceleration, position, and velocity values change every instant. Since this is impossible to compute in reality, I implemented the system with a time step of 0.001 (meaning that all variables of motion are updated every 0.001 time units).

\subsection{Visualization}

\subsubsection{Graphical Front-End}

To make the model more easy to visualize and understand, I developed a graphical front-end using PyQt5. It displays the cart and pole as rectangles on top of the linear track. It can be seen in Figure \ref{simulation}.

\begin{figure}[ht]
    \centering
    \includegraphics[width=\textwidth]{simulation}
    \caption{\label{simulation} A screenshot of the graphical front-end.}
\end{figure}

\subsubsection{Motion Plots}

For more precise static visualization of overshooting and other potential problems with control algorithms, I used Matplotlib \cite{matplotlib} to create plots over time of $x$, $\theta$, and $F$. These plots are seen throughout the rest of this paper.

\printbibliography

\end{document}